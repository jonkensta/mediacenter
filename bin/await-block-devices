#!/usr/bin/env python3

"""Script for awaiting block devices with optional power management."""

import argparse
import asyncio
import logging
import pathlib
import subprocess
import sys

import pyudev

logger = logging.getLogger(__name__)


def is_block_device_available(context: pyudev.Context, device_uuid: str) -> bool:
    """Check if block device with UUID device_uuid is available."""
    for device in context.list_devices(subsystem="block"):
        if device.properties.get("ID_FS_UUID") == device_uuid:
            return True
    return False


def all_devices_available(device_uuids: list[str]) -> bool:
    """Check if all block devices are available."""
    context = pyudev.Context()
    return all(is_block_device_available(context, uuid) for uuid in device_uuids)


def power_on_das(relay_device: pathlib.Path):
    """Power on the DAS via relay."""
    logger.info("Powering on DAS via relay at %s", relay_device)
    try:
        subprocess.run(
            ["/usr/local/bin/relay", str(relay_device), "close"],
            check=True,
            capture_output=True,
        )
    except subprocess.CalledProcessError as e:
        logger.error("Failed to power on DAS: %s", e.stderr.decode())
        raise


class DeviceTimeoutError(Exception):
    """Exception raised operation fails."""


async def await_block_device(
    device_uuid: str,
    poll_interval: float = 5.0,
    timeout: float = 60.0,
):
    """Await device of given UUID."""
    start_time = 0
    context = pyudev.Context()
    while not is_block_device_available(context, device_uuid):
        elapsed = start_time
        remaining = timeout - elapsed
        logger.info(
            "Waiting for device '%s' (%.1fs elapsed, %.1fs remaining)...",
            device_uuid, elapsed, remaining
        )
        await asyncio.sleep(poll_interval)
        start_time += poll_interval
        if start_time >= timeout:
            raise DeviceTimeoutError(f"Device '{device_uuid}' timed out.")

    logger.info("Device '%s' is available", device_uuid)


async def main():
    """Await block devices of given UUIDs with optional power management."""

    parser = argparse.ArgumentParser(description=main.__doc__)
    parser.add_argument(
        "uuids",
        nargs="+",
        help="List of UUIDs of devices to await",
    )
    parser.add_argument(
        "--poll-interval",
        type=float,
        default=5,
        help="Poll interval in seconds",
    )
    parser.add_argument(
        "--timeout",
        type=float,
        default=180,
        help="Timeout in seconds",
    )
    parser.add_argument(
        "--relay-device",
        type=pathlib.Path,
        help="USB relay device path (if provided, will power on DAS if devices not available)",
    )
    args = parser.parse_args()

    # If relay device specified, check if we need to power on
    if args.relay_device:
        if all_devices_available(args.uuids):
            logger.info("All devices already available, skipping power on")
        else:
            logger.info("Devices not available, powering on DAS")
            power_on_das(args.relay_device)

    # Wait for all devices
    tasks = [
        await_block_device(device_uuid, args.poll_interval, args.timeout)
        for device_uuid in args.uuids
    ]

    exceptions = await asyncio.gather(*tasks, return_exceptions=True)
    exceptions = [exception for exception in exceptions if exception is not None]
    for exception in exceptions:
        logger.error(str(exception))

    if exceptions:
        raise DeviceTimeoutError("One or more devices timed out.")

    logger.info("All devices are available.")


if __name__ == "__main__":
    logging.basicConfig(level=logging.INFO)

    try:
        asyncio.run(main())
    except KeyboardInterrupt:
        logger.info("Exiting...")
        sys.exit(0)
    except Exception as e:  # pylint: disable=broad-except
        logger.error(str(e))
        sys.exit(1)
