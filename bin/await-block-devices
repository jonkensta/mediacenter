#!/usr/bin/env python3

"""Script for awaiting block devices."""

import argparse
import asyncio
import logging
import sys

import pyudev

logger = logging.getLogger(__name__)


def is_block_device_available(context: pyudev.Context, device_uuid: str):
    """Check if block device with UUID device_uuid is available."""
    context = pyudev.Context()
    for device in context.list_devices(subsystem="block"):
        if device.properties.get("ID_FS_UUID") == device_uuid:
            return True
    return False


class DeviceTimeoutError(Exception):
    """Exception raised operation fails."""


async def await_block_device(
    device_uuid: str,
    poll_interval: float = 5.0,
    timeout: float = 60.0,
):
    """Await device of given UUID."""
    start_time = 0
    context = pyudev.Context()
    while not is_block_device_available(context, device_uuid):
        logging.info("Waiting for device '%s' to become available...", device_uuid)
        await asyncio.sleep(poll_interval)
        start_time += poll_interval
        if start_time >= timeout:
            raise DeviceTimeoutError(f"Device '{device_uuid}' timed out.")

    logger.info("Successfully awaited device '%s'.", device_uuid)


async def main():
    """Await block devices of given UUIDs."""

    parser = argparse.ArgumentParser(description=main.__doc__)
    parser.add_argument(
        "uuids",
        nargs="+",
        help="List of UUIDs of devices to await",
    )
    parser.add_argument(
        "--poll_interval",
        type=float,
        default=5,
        help="Poll interval in seconds",
    )
    parser.add_argument(
        "--timeout",
        type=float,
        default=60,
        help="Timeout in seconds",
    )
    args = parser.parse_args()

    tasks = [
        await_block_device(device_uuid, args.poll_interval, args.timeout)
        for device_uuid in args.uuids
    ]

    exceptions = await asyncio.gather(*tasks, return_exceptions=True)
    exceptions = [exception for exception in exceptions if exception is not None]
    for exception in exceptions:
        logger.error(str(exception))

    if exceptions:
        raise DeviceTimeoutError("One or more devices timed out.")

    logger.info("All devices are available.")


if __name__ == "__main__":
    logging.basicConfig(level=logging.INFO)

    try:
        asyncio.run(main())
    except KeyboardInterrupt:
        logger.info("Exiting...")
        sys.exit(0)
    except Exception as e:  # pylint: disable=broad-except
        logger.error(str(e))
        sys.exit(1)
